---
description: 
globs: 
alwaysApply: true
---
# Architecture

Этот документ описывает основные архитектурные решения и паттерны, принятые в проекте.

---

## Frontend

### 1. Структура директорий (Feature-Sliced Design)

Проект использует адаптированную версию методологии Feature-Sliced Design.

- **`src/app`:** Инициализация приложения (роутер, стор, провайдеры). (В текущей структуре это `main.tsx` и `App.tsx`)
- **`src/pages`:** Страницы приложения. Каждая страница — это компонент, который композирует в себе различные "фичи" и "виджеты".
- **`src/widgets`:** Самостоятельные блоки UI, состоящие из нескольких "фич" и "сущностей". Пример: шапка сайта (`Header`), подвал (`Footer`), панель навигации.
- **`src/features`:** Бизнес-сценарии пользователя. Каждая фича решает одну задачу. Например: `auth` (аутентификация), `exchange` (создание заявки на обмен).
    - Структура фичи: `components`, `hooks`, `services`, `store`, `types`, `constants`.
- **`src/entities`:** Бизнес-сущности. Например: `User`, `Order`, `Currency`. Этот слой содержит компоненты для отображения сущностей, хуки и сторы для работы с ними. (Сейчас частично реализовано внутри `features`).
- **`src/shared`:** Переиспользуемый код, не имеющий отношения к бизнес-логике.
    - `ui`: UI-кит (кнопки, инпуты, модальные окна).
    - `lib`: Вспомогательные функции и хуки (например, работа с `localStorage`).
    - `config`: Конфигурация приложения (роуты, переменные окружения).
    - `api`: Настройка инстанса `axios`, базовые типы для API.

### 2. Управление состоянием

- **React Query (`@tanstack/react-query`):**
    - **Назначение:** Основной инструмент для работы с состоянием сервера (Server State). Используется для всех CRUD-операций с API (получение, создание, обновление, удаление данных).
    - **Кеширование:** Управляет кешированием, инвалидацией и фоновым обновлением данных.
    - **Обязательно:** Все асинхронные запросы к бэкенду должны быть обернуты в хуки React Query (`useQuery`, `useMutation`).

- **Zustand:**
    - **Назначение:** Управление глобальным состоянием клиента (Client State), которое не связано с сервером или которое нужно разделять между множеством несвязанных компонентов.
    - **Примеры:**
        - Состояние аутентификации пользователя (токен, информация о пользователе, статус `isAuth`).
        - Состояние UI (открыта ли модалка, какая тема выбрана).
        - Данные, которые вводятся в многошаговых формах.
    - **Не использовать для:** Хранения данных, полученных с сервера. Для этого есть React Query.

- **Локальное состояние (`useState`, `useReducer`):**
    - **Назначение:** Управление состоянием, которое относится только к одному компоненту и не требуется за его пределами.
    - **Примеры:** Состояние инпутов в форме, состояние открыт/закрыт для выпадающего списка.

### 3. Взаимодействие с API

- **Axios:** Используется для выполнения HTTP-запросов. Создается единый инстанс `axios` в `src/shared/api/` или `src/config/api.ts`.
- **Перехватчики (Interceptors):**
    - **Request Interceptor:** Автоматически добавляет `Authorization` заголовок (JWT токен из Zustand) ко всем исходящим запросам.
    - **Response Interceptor:** Обрабатывает типичные ошибки (например, 401 Unauthorized для разлогина пользователя) в одном месте.
- **Типизация:**
    - **Zod:** Используется для валидации ответов от API. Это гарантирует, что данные, приходящие с бэкенда, соответствуют типам TypeScript на фронтенде. Схемы Zod должны быть определены рядом с типами данных.

---

## Backend

### 1. Django Apps

- **Принцип единственной ответственности:** Каждое Django-приложение (`app`) должно отвечать за одну четкую бизнес-сущность или функциональную область.
    - `users`: Управление пользователями, профилями, аутентификацией (валидация токена).
    - `orders`: Управление заявками на обмен.
    - `exchange`: Управление валютами, курсами, направлениями обмена.
    - `core` или `common`: Может быть создано для общих моделей, миксинов, утилит, которые используются в нескольких приложениях.
- **Разделение логики:**
    - **`views.py`:** Содержат только логику, связанную с обработкой HTTP-запросов и ответов. Они принимают запрос, вызывают сервисы для выполнения бизнес-логики и возвращают ответ, используя сериализаторы.
    - **`serializers.py`:** Отвечают за преобразование данных (Python objects <-> JSON) и валидацию входящих данных.
    - **`services.py` (нестандартный файл, но рекомендуется):** Создайте этот файл для вынесения сложной бизнес-логики из `views`. Например, `create_order_and_notify_user()`. Это делает `views` тоньше и упрощает тестирование логики.
    - **`selectors.py` (нестандартный файл, но рекомендуется):** Для сложных запросов к БД (`QuerySet`), которые инкапсулируют логику выборки данных. Например, `get_user_active_orders(user)`.
